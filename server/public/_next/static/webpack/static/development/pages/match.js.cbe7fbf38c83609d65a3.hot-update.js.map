{"version":3,"file":"static/webpack/static/development/pages/match.js.cbe7fbf38c83609d65a3.hot-update.js","sources":["webpack:///./src/utils/MatchConnect.js"],"sourcesContent":["import fetch from 'isomorphic-unfetch';\nimport _ from 'lodash';\nimport qs from 'qs';\n// import Dispatcher from '../utils/Dispatcher';\nconst Dispatcher = require('../utils/Dispatcher');\n\nimport Config from '../Config';\n\nclass MatchConnect extends Dispatcher {\n  constructor() {\n    super();\n    this.socket = null;\n    this.playerId = null;\n    this.rounds = [];\n    this.evts = null;\n\n    this.goToGamePresentation = this.goToGamePresentation.bind(this);\n    this.goToLastScoreboard = this.goToLastScoreboard.bind(this);\n    this.goToScoreboard = this.goToScoreboard.bind(this);\n    this.goToNextRound = this.goToNextRound.bind(this);\n    this.goToGameTitle = this.goToGameTitle.bind(this);\n    this.goToGameWait = this.goToGameWait.bind(this);\n    this.onWaitRoom = this.onWaitRoom.bind(this);\n    this.endMatch = this.endMatch.bind(this);\n  }\n\n  attachEvents() {\n    this.socket\n      .on('test', (text) => console.log('on test text', text))\n      .on('connection', () => console.log('client nsp connection'))\n      .on('join', () => console.log('client nsp join'))\n      .on('match.rounds', this.setRounds)\n      // .on('match.waitroom', this.goToWaitRoom)\n      .on(this.evts.MATCH_WAITROOM, this.onWaitRoom)\n      // .on('match.mid.scoreboard', this.goToScoreboard)\n      .on(this.evts.GAME_PREPARE, this.goToGameTitle)\n      .on(this.evts.MATCH_MID_SCOREBOARD, this.goToScoreboard)\n      // .on('game.wait', this.goToGameWait)\n      .on(this.evts.GAME_WAIT, this.goToGameWait)\n      .on(this.evts.GAME_PRESENTATION, this.goToGamePresentation)\n      // .on('match.last.scoreboard', this.goToLastScoreboard)\n      // .on('match.next.round', this.goToNextRound)\n      .on(this.evts.MATCH_NEXT_ROUND, this.goToNextRound)\n      // .on('match.end', this.goToLastScoreboard)\n      .on(this.evts.MATCH_END, this.goToLastScoreboard)\n      .on('disconnect', this.removeEvents);\n  }\n\n  endMatch() {\n    console.log('>> utils/Api#endMatch');\n    this.dispatch(this.evts.MATCH_END);\n  }\n\n  goToNextRound(round) {\n    console.log('>> utils/Api#goToNextRound');\n    // console.log('utils/Api#goToNextRound round', round);\n    this.dispatch(this.evts.MATCH_NEXT_ROUND, round);\n  }\n\n  goToGamePresentation(playerIds) {\n    console.log('>> utils/Api#goToGamePresentation');\n    // console.log('utils/Api#goToNextRound round', round);\n    this.dispatch(this.evts.GAME_PRESENTATION, playerIds);\n  }\n\n  goToScoreboard(results) {\n    console.log('>> utils/Api#gotToScoreboard');\n    this.dispatch(this.evts.MATCH_MID_SCOREBOARD, results);\n  }\n\n  goToLastScoreboard(results) {\n    console.log('>> utils/Api#goToLastScoreboard');\n    this.dispatch(this.evts.MATCH_END, results);\n    // this.socket.disconnect();\n  }\n\n  goToGameTitle(instructions) {\n    console.log('>> utils/Api#goToGameTitle');\n    this.dispatch(this.evts.GAME_PREPARE, instructions);\n  }\n\n  onWaitRoom(room) {\n    console.log('>> utils/Api#onWaitRoom');\n    console.log('utils/Api#onWaitRoom room', room);\n    this.dispatch(this.evts.MATCH_WAITROOM, room);\n  }\n\n  goToGameWait() {\n    console.log('>> utils/Api#goToGameWait');\n    this.dispatch(this.evts.GAME_WAIT);\n  }\n\n  connect() {\n    return new Promise((resolve) => {\n      this.evts = kwa.constants.cEvents;\n      const url = Config.API_URL;\n      console.log('utils/Api#connect url', url);\n      this.socket = io(url);\n      this.playerId = this.socket.id;\n      console.log('playerId', this.playerId);\n      this.attachEvents();\n      resolve();\n      // socket.on('room', (room) => {\n      //   console.log('utils/Api#connect room', room);\n      //   // set it from socket var as it seems in this.socket\n      //   // it is not readily available\n      //   this.playerId = socket.id;\n      //   this.socket = io(`${url}${room}`);\n      //   // console.log('utils/Api#connect socket', socket);\n      //   // console.log('utils/Api#connect this.socket', this.socket);\n      //   // debugger;\n\n      //   // console.log('utils/Api#connect this.playerId', this.playerId);\n      //   this.attachEvents();\n      //   resolve();\n      // });\n      socket.on('disconnect', () => {\n        console.log('socket on disconnect');\n        socket.removeAllListeners();\n      });\n    });\n  }\n\n  removeEvents() {\n    console.log('>> utils/Api#removeEvents');\n    // this.socket.removeAllListeners();\n  }\n\n  setRounds(rounds) {\n    // console.log('>> utils/Api#setRounds');\n    // console.log('utils/Api#setRounds rounds', rounds);\n    this.rounds = rounds;\n  }\n\n  setSocket(socket) {\n    // console.log('utils/Api#setSocket socket', socket);\n    this.socket = socket;\n    this.playerId = socket.id.split('#')[1];\n  }\n}\n\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = new MatchConnect();\n    }\n  }\n\n  getInstance() {\n    return Singleton.instance;\n  }\n}\n\nmodule.exports = Singleton;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;;;;;AAJA;AACA;AACA;AAGA;;;;;AACA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAeA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAHA;AAAA;AAAA;AAcA;AAdA;AAAA;AAmBA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAEA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAlIA;AACA;AAoIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;AAGA;;;;A","sourceRoot":""}